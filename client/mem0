
#!/usr/bin/env python3

import sys
import os

# Add the vendor directory to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'vendor'))
import argparse
import requests
import json
import subprocess
from datetime import datetime

# Configuration loading
def load_config():
    config_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'mem0.config.json')
    default_config = {
        "server": {"host": "127.0.0.1", "port": 13370, "timeout": 10},
        "client": {"default_context_strategy": "git_branch", "cache_ttl": 30, "debug": False},
        "shell": {"enabled": True, "capture_patterns": {"include": ["*"], "exclude": ["ls", "cd", "pwd", "clear", "exit"]}},
        "storage": {"data_file": "mem0_data.json", "backup_enabled": True, "max_memories_per_context": 1000}
    }
    
    try:
        if os.path.exists(config_path):
            with open(config_path, 'r') as f:
                user_config = json.load(f)
                # Merge with defaults
                for section in default_config:
                    if section in user_config:
                        default_config[section].update(user_config[section])
        return default_config
    except Exception:
        return default_config

config = load_config()
API_PORT = os.getenv("MEM0_PORT", config["server"]["port"])
API_HOST = config["server"]["host"]
API_URL = f"http://{API_HOST}:{API_PORT}"
REQUEST_TIMEOUT = config["server"]["timeout"]

def get_active_context():
    try:
        # Get active context from server
        response = requests.get(f"{API_URL}/context/active", timeout=REQUEST_TIMEOUT)
        if response.status_code == 200:
            active_context = response.json().get("recording_context")
            if active_context:
                return active_context
    except:
        pass
    
    # No active context - user must specify --context or start a context first
    raise ValueError("No active context. Use --context <name> or start a context first with 'context start <name>'")

def remember(args):
    context = args.context if args.context else get_active_context()
    
    # Handle both JSON and plain text input
    try:
        # Try to parse as JSON first
        payload_data = json.loads(args.text_or_json)
        if not all(k in payload_data for k in ['type', 'source', 'data']):
            raise ValueError("JSON payload must contain 'type', 'source', and 'data' keys.")
    except (json.JSONDecodeError, ValueError):
        # If not JSON, treat as plain text and create structured payload
        payload_data = {
            "type": "note",
            "source": "cli",
            "data": {
                "text": args.text_or_json,
                "timestamp": str(datetime.now()),
                "context": context
            }
        }

    payload = {
        "context": context,
        "payload": payload_data
    }
    
    try:
        response = requests.post(f"{API_URL}/memory", json=payload, timeout=REQUEST_TIMEOUT)
        response.raise_for_status()
        print(response.json().get("message", ""))
    except requests.exceptions.ConnectionError:
        print("Error: Could not connect to mem0 server. Is it running? (./manage.sh start)")
    except requests.exceptions.Timeout:
        print("Error: Request timed out. Server may be overloaded.")
    except requests.exceptions.HTTPError as e:
        print(f"Error: Server returned HTTP {e.response.status_code}")
    except Exception as e:
        print(f"Error: Unexpected error occurred: {e}")

def recall(args):
    try:
        if args.context:
            # Specific context requested
            context = args.context
            response = requests.get(f"{API_URL}/memory", params={"context": context}, timeout=REQUEST_TIMEOUT)
        else:
            # No context specified - show all memories from all contexts
            response = requests.get(f"{API_URL}/memory/all", timeout=REQUEST_TIMEOUT)
        
        response.raise_for_status()
        memories = response.json()
        
        if not memories:
            if args.context:
                print(f"No memories found for context: {args.context}")
            else:
                print("No memories found in any context")
            return
            
        for entry in memories:
            print(json.dumps(entry, indent=4))
            
    except requests.exceptions.ConnectionError:
        print("Error: Could not connect to mem0 server. Is it running? (./manage.sh start)")
    except requests.exceptions.Timeout:
        print("Error: Request timed out. Server may be overloaded.")
    except requests.exceptions.HTTPError as e:
        print(f"Error: Server returned HTTP {e.response.status_code}")
    except Exception as e:
        print(f"Error: Unexpected error occurred: {e}")

def context_start(args):
    try:
        response = requests.post(f"{API_URL}/context/start", params={"context": args.name}, timeout=REQUEST_TIMEOUT)
        response.raise_for_status()
        print(response.json()["message"])
        print(f"Use: mem0_context_start {args.name} (for shell integration)")
    except requests.exceptions.ConnectionError:
        print("Error: Could not connect to mem0 server. Is it running? (./manage.sh start)")
    except requests.exceptions.Timeout:
        print("Error: Request timed out. Server may be overloaded.")
    except requests.exceptions.HTTPError as e:
        print(f"Error: Server returned HTTP {e.response.status_code}")
    except Exception as e:
        print(f"Error: Unexpected error occurred: {e}")

def context_stop(args):
    try:
        if hasattr(args, 'name') and args.name:
            response = requests.post(f"{API_URL}/context/stop", params={"context": args.name}, timeout=REQUEST_TIMEOUT)
        else:
            response = requests.post(f"{API_URL}/context/stop", timeout=REQUEST_TIMEOUT)
        response.raise_for_status()
        print(response.json()["message"])
    except requests.exceptions.ConnectionError:
        print("Error: Could not connect to mem0 server. Is it running? (./manage.sh start)")
    except requests.exceptions.Timeout:
        print("Error: Request timed out. Server may be overloaded.")
    except requests.exceptions.HTTPError as e:
        print(f"Error: Server returned HTTP {e.response.status_code}")
    except Exception as e:
        print(f"Error: Unexpected error occurred: {e}")

def context_active(args):
    try:
        # Check if MEM0_CONTEXT is set for this terminal
        terminal_context = os.getenv("MEM0_CONTEXT")
        if terminal_context:
            # Verify the context still exists on the server
            response = requests.get(f"{API_URL}/contexts", timeout=REQUEST_TIMEOUT)
            response.raise_for_status()
            contexts = response.json().get("contexts", [])
            context_names = [c["name"] for c in contexts]
            
            if terminal_context in context_names:
                print(f"Terminal context: {terminal_context}")
            else:
                print(f"Terminal context '{terminal_context}' no longer exists (deleted)")
                print("Clear with: unset MEM0_CONTEXT")
        else:
            print("No terminal context set")
    except Exception as e:

    def context_start(self, name):
        """Start recording to a context"""
        response = self.make_request('POST', f'/context/start?context={name}')

        if response.status_code == 200:
            result = response.json()
            print(result['message'])
            print(f"üí° Use: mem0_context_start {name} (for shell integration)")
        else:
            print(f"‚ùå Failed to start context: {response.text}")

    def context_stop(self, name=None):
        """Stop recording"""
        if name:
            response = self.make_request('POST', f'/context/stop?context={name}')
        else:
            response = self.make_request('POST', '/context/stop')

        if response.status_code == 200:
            result = response.json()
            print(result['message'])
        else:
            print(f"‚ùå Failed to stop context: {response.text}")

    def context_active(self):
        """Show active context"""
        response = self.make_request('GET', '/context/active')

        if response.status_code == 200:
            result = response.json()
            context = result.get('recording_context')
            if context:
                print(f"üéØ Terminal context: {context}")
            else:
                print("üì≠ No terminal context set")
        else:
            print(f"‚ùå Failed to get active context: {response.text}")

    def contexts(self):
        """List all contexts"""
        response = self.make_request('GET', '/contexts')

        if response.status_code == 200:
            result = response.json()
            contexts = result.get('contexts', [])

            if not contexts:
                print("üìù No contexts found")
                return

            print("üìã Available contexts:")
            for ctx in contexts:
                status = "ACTIVE" if ctx['is_active'] else "inactive"
                created = ctx['created_at'][:19]  # Truncate timestamp
                print(f"  - {ctx['name']} ({status}) - created: {created}")
        else:
            print(f"‚ùå Failed to list contexts: {response.text}")

    def create_context(self, name, description, visibility):
        """Create a new context with ownership"""
        data = {
            "name": name,
            "description": description or "",
            "visibility": visibility
        }
        
        response = self.make_request('POST', '/contexts', json=data)
        
        if response.status_code == 200:
            result = response.json()
            print(f"‚úÖ Context '{name}' created successfully")
            print(f"üÜî ID: {result['id']}")
            print(f"üëÅÔ∏è Visibility: {result['visibility']}")
            return result
        else:
            print(f"‚ùå Failed to create context: {response.text}")
            return None

    def create_organization(self, name, description):
        """Create a new organization"""
        data = {"name": name}
        if description:
            data["description"] = description
            
        response = self.make_request('POST', '/organizations', json=data)
        
        if response.status_code == 200:
            result = response.json()
            print(f"‚úÖ Organization '{name}' created successfully")
            print(f"üÜî ID: {result['id']}")
            return result
        else:
            print(f"‚ùå Failed to create organization: {response.text}")
            return None

    def list_organizations(self):
        """List all organizations"""
        response = self.make_request('GET', '/organizations')
        
        if response.status_code == 200:
            result = response.json()
            orgs = result.get('organizations', [])
            
            if not orgs:
                print("üè¢ No organizations found")
                return
            
            print("üè¢ Organizations:")
            for org in orgs:
                print(f"  - {org['name']} (ID: {org['id']})")
        else:
            print(f"‚ùå Failed to list organizations: {response.text}")

    def create_team(self, name, org_id, description):
        """Create a new team"""
        data = {"name": name}
        if org_id:
            data["organization_id"] = org_id
        if description:
            data["description"] = description
            
        response = self.make_request('POST', '/teams', json=data)
        
        if response.status_code == 200:
            result = response.json()
            print(f"‚úÖ Team '{name}' created successfully")
            print(f"üÜî ID: {result['id']}")
            if result.get('organization_id'):
                print(f"üè¢ Organization ID: {result['organization_id']}")
            return result
        else:
            print(f"‚ùå Failed to create team: {response.text}")
            return None

    def add_team_member(self, team_id, user_id, role):
        """Add a member to a team"""
        data = {"user_id": user_id, "role": role}
        
        response = self.make_request('POST', f'/teams/{team_id}/members', json=data)
        
        if response.status_code == 200:
            result = response.json()
            print(f"‚úÖ User {user_id} added to team {team_id} with role '{role}'")
            return result
        else:
            print(f"‚ùå Failed to add team member: {response.text}")
            return None

    def get_team_members(self, team_id):
        """Get team members"""
        response = self.make_request('GET', f'/teams/{team_id}/members')
        
        if response.status_code == 200:
            result = response.json()
            members = result.get('members', [])
            
            if not members:
                print(f"üë• No members found in team {team_id}")
                return
            
            print(f"üë• Team {team_id} members:")
            for member in members:
                user = member['user']
                role = member['role']
                joined = member['joined_at'][:10]  # Date only
                print(f"  - {user['username']} ({role}) - joined: {joined}")
        else:
            print(f"‚ùå Failed to get team members: {response.text}")

    def get_user_teams(self):
        """Get teams the current user belongs to"""
        response = self.make_request('GET', '/users/me/teams')
        
        if response.status_code == 200:
            result = response.json()
            teams = result.get('teams', [])
            
            if not teams:
                print("üë§ You are not a member of any teams")
                return
            
            print("üë• Your teams:")
            for team in teams:
                org_info = f" (Org: {team['organization_id']})" if team['organization_id'] else ""
                print(f"  - {team['name']}{org_info} - ID: {team['id']}")
        else:
            print(f"‚ùå Failed to get user teams: {response.text}")

    def share_context(self, context_id, target_type, target_id, permission):
        """Share a context with user, team, or organization"""
        data = {
            "target_type": target_type,
            "target_id": target_id,
            "permission_level": permission
        }
        
        response = self.make_request('POST', f'/contexts/{context_id}/share', json=data)
        
        if response.status_code == 200:
            result = response.json()
            print(f"‚úÖ Context {context_id} shared with {target_type} {target_id}")
            print(f"üîê Permission: {permission}")
            return result
        else:
            print(f"‚ùå Failed to share context: {response.text}")
            return None

    def get_user_contexts(self):
        """Get all contexts the user can access"""
        response = self.make_request('GET', '/users/me/contexts')
        
        if response.status_code == 200:
            result = response.json()
            contexts = result.get('contexts', [])
            
            if not contexts:
                print("üìù No accessible contexts found")
                return
            
            print("üìã Your accessible contexts:")
            for ctx in contexts:
                owner_info = f" - Owner: {ctx['owner']}" if ctx.get('owner') else ""
                print(f"  - {ctx['name']} ({ctx['visibility']}) - ID: {ctx['id']}{owner_info}")
        else:
            print(f"‚ùå Failed to get user contexts: {response.text}")
    parser = argparse.ArgumentParser(description="mem0 - Memory Layer for AI Agents")
    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Authentication commands
    auth_parser = subparsers.add_parser('auth', help='Authentication commands')
    auth_subparsers = auth_parser.add_subparsers(dest='auth_command')

    # Login
    login_parser = auth_subparsers.add_parser('login', help='Login to mem0')
    login_parser.add_argument('--username', required=True, help='Username')
    login_parser.add_argument('--password', required=True, help='Password')

    # Register
    register_parser = auth_subparsers.add_parser('register', help='Register new user')
    register_parser.add_argument('--username', required=True, help='Username')
    register_parser.add_argument('--password', required=True, help='Password')
    register_parser.add_argument('--email', help='Email address')

    # Logout
    auth_subparsers.add_parser('logout', help='Logout from mem0')

    # User info
    auth_subparsers.add_parser('me', help='Show current user information')

    # Organization commands
    org_parser = subparsers.add_parser('org', help='Organization management')
    org_subparsers = org_parser.add_subparsers(dest='org_command')

{{ ... }}
    context_create_parser = subparsers.add_parser('context-create', help='Create context with ownership')
    context_create_parser.add_argument('--name', required=True, help='Context name')
    context_create_parser.add_argument('--description', help='Context description')
    context_create_parser.add_argument('--visibility', choices=['private', 'team', 'organization', 'public'], default='private', help='Visibility level')

    # Memory commands
    remember_parser = subparsers.add_parser('remember', help='Store a memory')
    remember_parser.add_argument('payload', help='JSON payload or text')
    remember_parser.add_argument('--context', help='Context name')

    # Recall
    recall_parser = subparsers.add_parser('recall', help='Retrieve memories')
    recall_parser.add_argument('--context', help='Context name to filter by')

    # Context commands
    context_parser = subparsers.add_parser('context', help='Context management')
    context_subparsers = context_parser.add_subparsers(dest='context_command')

    # Context start
    start_parser = context_subparsers.add_parser('start', help='Start recording to context')
    start_parser.add_argument('name', help='Context name')

    # Context stop
    stop_parser = context_subparsers.add_parser('stop', help='Stop recording')
    stop_parser.add_argument('name', nargs='?', help='Context name (optional)')

    # Context active
    context_subparsers.add_parser('active', help='Show active context')

    # Context list
    context_subparsers.add_parser('list', help='List all contexts')

    # Context delete
    delete_parser = context_subparsers.add_parser('delete', help='Delete context')
    delete_parser.add_argument('name', help='Context name')

    # Legacy command aliases
    subparsers.add_parser('contexts', help='List all contexts')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return
{{ ... }}
        parser.print_help()

if __name__ == "__main__":
    main()
