name: Mac Studio – Validate All SPECs (native + http)

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'specs/**'
      - 'scripts/**'
      - 'server/**'
      - '.github/workflows/macstudio-validate-specs-matrix.yml'
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch: {}

permissions:
  contents: read

# ──────────────────────────────────────────────────────────────────────────────
# 1) Enumerate SPEC directories dynamically
# ──────────────────────────────────────────────────────────────────────────────
jobs:
  enumerate-specs:
    runs-on: ubuntu-latest
    outputs:
      specs: ${{ steps.gather.outputs.specs }}
    steps:
      - uses: actions/checkout@v4

      - id: gather
        shell: bash
        run: |
          set -euo pipefail
          MAP=()
          while IFS= read -r -d '' dir; do
            name="$(basename "$dir")"
            MAP+=("{\"path\":\"$dir\",\"name\":\"$name\"}")
          done < <(find specs -maxdepth 1 -mindepth 1 -type d -print0 | \
                   xargs -0 -I{} bash -lc '[ -f "{}/SPEC.md" ] && echo -n "{}\0"')
          JSON="[$(IFS=,; echo "${MAP[*]-}")]"
          echo "specs=$JSON" >> "$GITHUB_OUTPUT"
          echo "Detected specs: $JSON"

# ──────────────────────────────────────────────────────────────────────────────
# 2) Validate each SPEC for both memory providers
# ──────────────────────────────────────────────────────────────────────────────
  validate:
    name: SPEC ${{ matrix.spec.name }} • provider=${{ matrix.provider }}
    needs: enumerate-specs
    runs-on: [self-hosted, macstudio]
    timeout-minutes: 70

    # single Studio host: serialize all jobs and cancel superseded runs
    concurrency:
      group: macstudio-validate-specs-matrix
      cancel-in-progress: true

    strategy:
      fail-fast: false
      matrix:
        spec: ${{ fromJson(needs.enumerate-specs.outputs.specs) }}
        provider: [native, http]

    env:
      # Ports (align with your scripts/.env.example)
      POSTGRES_PORT: "5433"
      PGBOUNCER_PORT: "6432"
      API_PORT: "13370"
      MEM0_PORT: "7070"

      # DB / App secrets
      POSTGRES_USER: "nina"
      POSTGRES_DB: "nina"
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      NINAIVALAIGAL_JWT_SECRET: ${{ secrets.NINAIVALAIGAL_JWT_SECRET || 'dev-secret-change-in-production' }}

      # Provider (stack scripts start mem0 automatically when = http)
      MEMORY_PROVIDER: ${{ matrix.provider }}
      MEMORY_HTTP_BASE: "http://127.0.0.1:7070"

      API_RELOAD: "false"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure Apple Container CLI on PATH
        run: |
          if [ -x /opt/homebrew/bin/container ] && [ ! -x /usr/local/bin/container ]; then
            sudo ln -sf /opt/homebrew/bin/container /usr/local/bin/container
          fi
          which container && container --version

      - name: System Detection
        run: |
          echo "SPEC: ${{ matrix.spec.name }}  PATH: ${{ matrix.spec.path }}"
          echo "PROVIDER: ${{ matrix.provider }}"
          make system-info

      - name: Detect host IP for containers (LAN/Tailscale)
        shell: bash
        run: |
          HOST_IP="$(ipconfig getifaddr en0 2>/dev/null || echo 127.0.0.1)"
          echo "POSTGRES_HOST=${HOST_IP}" >> "$GITHUB_ENV"
          echo "Using POSTGRES_HOST=${HOST_IP}"

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ runner.os }}-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            pip-${{ runner.os }}-

      - name: Install Python deps (best-effort)
        shell: bash
        run: |
          python -m pip install -U pip
          if ls requirements*.txt >/dev/null 2>&1; then
            pip install -r requirements.txt || true
            [ -f requirements-dev.txt ] && pip install -r requirements-dev.txt || true
          fi
          pip install -q pytest httpx || true

      # ── Start services (DB → PgB → mem0? → API → UI) ────────────────────────
      - name: Start stack
        shell: bash
        run: make stack-up
        # NOTE: your nv-stack-start.sh auto-starts mem0 when MEMORY_PROVIDER=http

      - name: Stack status
        shell: bash
        run: make stack-status

      # ── SLO Health Monitoring ──────────────────────────────────────────────
      - name: Health Check SLO Validation
        shell: bash
        run: |
          echo "=== SLO Health Check Validation ==="
          
          # Test basic health endpoint
          echo "Testing /health endpoint..."
          HEALTH_START=$(date +%s%3N)
          if curl -f -s "http://127.0.0.1:${{ env.API_PORT }}/health" > /dev/null; then
            HEALTH_END=$(date +%s%3N)
            HEALTH_LATENCY=$((HEALTH_END - HEALTH_START))
            echo "✅ Basic health check: ${HEALTH_LATENCY}ms"
            
            # SLO check: <50ms for basic health
            if [ $HEALTH_LATENCY -gt 50 ]; then
              echo "⚠️  Health check latency exceeds SLO target (50ms): ${HEALTH_LATENCY}ms"
            fi
          else
            echo "❌ Basic health check failed"
            exit 1
          fi
          
          # Test detailed health endpoint
          echo "Testing /health/detailed endpoint..."
          DETAILED_START=$(date +%s%3N)
          DETAILED_RESPONSE=$(curl -f -s "http://127.0.0.1:${{ env.API_PORT }}/health/detailed")
          DETAILED_END=$(date +%s%3N)
          DETAILED_LATENCY=$((DETAILED_END - DETAILED_START))
          
          echo "✅ Detailed health check: ${DETAILED_LATENCY}ms"
          echo "$DETAILED_RESPONSE" | jq '.'
          
          # SLO check: <100ms for detailed health
          if [ $DETAILED_LATENCY -gt 100 ]; then
            echo "⚠️  Detailed health check latency exceeds SLO target (100ms): ${DETAILED_LATENCY}ms"
          fi
          
          # Check SLO compliance from response
          SLO_COMPLIANT=$(echo "$DETAILED_RESPONSE" | jq -r '.slo_compliant // false')
          if [ "$SLO_COMPLIANT" = "true" ]; then
            echo "✅ SLO compliance check passed"
          else
            echo "⚠️  SLO compliance check failed"
          fi

      - name: Metrics Endpoint Validation
        shell: bash
        run: |
          echo "=== Prometheus Metrics Validation ==="
          
          # Test metrics endpoint
          METRICS_START=$(date +%s%3N)
          METRICS_RESPONSE=$(curl -f -s "http://127.0.0.1:${{ env.API_PORT }}/metrics")
          METRICS_END=$(date +%s%3N)
          METRICS_LATENCY=$((METRICS_END - METRICS_START))
          
          echo "✅ Metrics endpoint: ${METRICS_LATENCY}ms"
          
          # SLO check: <200ms for metrics
          if [ $METRICS_LATENCY -gt 200 ]; then
            echo "⚠️  Metrics endpoint latency exceeds SLO target (200ms): ${METRICS_LATENCY}ms"
          fi
          
          # Validate metrics format
          if echo "$METRICS_RESPONSE" | grep -q "ninaivalaigal_"; then
            echo "✅ Prometheus metrics format validated"
            
            # Count metrics
            METRIC_COUNT=$(echo "$METRICS_RESPONSE" | grep -c "^ninaivalaigal_" || echo "0")
            echo "📊 Exported metrics: $METRIC_COUNT"
          else
            echo "❌ Invalid metrics format"
            exit 1
          fi

      - name: Database Performance Check
        shell: bash
        run: |
          echo "=== Database Performance Validation ==="
          
          # Run database statistics
          make db-stats || echo "Database stats collection failed"
          
          # Test PgBouncer stats if available
          if make pgb-stats 2>/dev/null; then
            echo "✅ PgBouncer statistics available"
          else
            echo "⚠️  PgBouncer statistics not available"
          fi

      - name: mem0 Authentication Test
        if: matrix.provider == 'http'
        shell: bash
        env:
          MEMORY_SHARED_SECRET: test-secret-for-ci
        run: |
          echo "=== mem0 Sidecar Authentication Test ==="
          
          # Test authentication with the HTTP memory provider
          if make test-mem0-auth; then
            echo "✅ mem0 authentication tests passed"
          else
            echo "❌ mem0 authentication tests failed"
            exit 1
          fi

      # ── Security Scanning ──────────────────────────────────────────────────
      - name: SBOM Generation (API)
        if: always()
        uses: anchore/sbom-action@v0
        with:
          image: ninaivalaigal-api:latest
          format: spdx-json
          output-file: sbom-api.spdx.json

      - name: SBOM Generation (mem0)
        if: always()
        uses: anchore/sbom-action@v0
        with:
          image: ninaivalaigal-mem0:latest
          format: spdx-json
          output-file: sbom-mem0.spdx.json

      - name: SBOM Generation (UI)
        if: always()
        uses: anchore/sbom-action@v0
        with:
          image: ninaivalaigal-ui:latest
          format: spdx-json
          output-file: sbom-ui.spdx.json

      - name: Vulnerability Scan (API)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ninaivalaigal-api:latest
          format: 'table'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          exit-code: '1'

      - name: Vulnerability Scan (mem0)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ninaivalaigal-mem0:latest
          format: 'table'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          exit-code: '1'

      - name: Vulnerability Scan (UI)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ninaivalaigal-ui:latest
          format: 'table'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          exit-code: '1'

      # ── SPEC under test ─────────────────────────────────────────────────────
      - name: Run SPEC tests
        shell: bash
        env:
          API_BASE: "http://127.0.0.1:${{ env.API_PORT }}"
        run: |
          make spec-test ID=${{ matrix.spec.name }}

      # ── Artifacts & Cleanup (always) ────────────────────────────────────────
      - name: Collect logs and security artifacts
        if: always()
        shell: bash
        run: |
          mkdir -p artifacts
          make stack-status || true
          container logs nv-db > artifacts/db.log 2>&1 || true
          container logs nv-pgbouncer > artifacts/pgbouncer.log 2>&1 || true
          container logs nv-mem0 > artifacts/mem0.log 2>&1 || true
          container logs nv-api > artifacts/api.log 2>&1 || true
          container logs nv-ui > artifacts/ui.log 2>&1 || true
          # Move SBOM files to artifacts
          mv sbom-*.spdx.json artifacts/ 2>/dev/null || true
          
          # Collect SLO metrics
          echo "=== SLO Metrics Collection ===" > artifacts/slo-report.txt
          curl -s "http://127.0.0.1:${{ env.API_PORT }}/health/detailed" >> artifacts/slo-report.txt 2>/dev/null || echo "Health check failed" >> artifacts/slo-report.txt
          curl -s "http://127.0.0.1:${{ env.API_PORT }}/metrics" | grep "ninaivalaigal_" >> artifacts/slo-report.txt 2>/dev/null || echo "Metrics collection failed" >> artifacts/slo-report.txt
          
          # Rename files with spec and provider info
          for f in artifacts/*.log; do \
            mv "$f" "${f%.log}-${{ matrix.spec.name }}-${{ matrix.provider }}.log" 2>/dev/null || true; \
          done
          for f in artifacts/sbom-*.spdx.json; do \
            base=$(basename "$f" .spdx.json)
            mv "$f" "artifacts/${base}-${{ matrix.spec.name }}-${{ matrix.provider }}.spdx.json" 2>/dev/null || true; \
          done
          mv artifacts/slo-report.txt "artifacts/slo-report-${{ matrix.spec.name }}-${{ matrix.provider }}.txt" 2>/dev/null || true

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macstudio-${{ matrix.spec.name }}-${{ matrix.provider }}
          path: artifacts/

      - name: Stop stack
        if: always()
        shell: bash
        run: make stack-down
